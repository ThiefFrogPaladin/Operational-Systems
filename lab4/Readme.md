Группа: Аэ-21-22

Команда:

Васильев П.А. - все роли
Заказчик: Емельянов Д.М.


ПОСТАНОВКА ЗАДАЧИ

Лабораторная работа №4 выполняется бригадой и предполагает разработку одного bash‑скрипта для анализа данных по студентам на основе файловой системы преподавателя из ЛР3.
​
В моём варианте заказчик требует реализовать следующие функции по заданному номеру группы:

вывод имени студента с минимальным количеством пересдач тестов и числа этих пересдач;

вывод списка студентов группы, чьи имена не соответствуют формату ФамилияИО (латиница, без пробелов).
​

В качестве исходных данных используются:

файлы групп students/groups/<номер_группы> (по одному студенту в строке);
​

файлы тестов двух предметов: Поп-Культуроведение/tests/TEST-[1-4] и Цирковое_Дело/tests/TEST-[1-4], формат CSV Группа;Студент;Дата;Баллы;Оценка.
​


ТЕХНИЧЕСКОЕ ЗАДАНИЕ ДЛЯ РАЗРАБОТКИ СКРИПТА
Общие сведения:

Название скрипта: lab4.sh.

Общая справка: флаг -h/--help без команды.

Формат вызова: ./lab4.sh [команда] [параметры].
​

Команда 1: retakes
Назначение:

По номеру группы вывести имя студента с минимальным числом пересдач и количество пересдач.

Формат:

./lab4.sh retakes <номер_группы>

Входные данные:

Номер группы вида A-XX-XX или Ae-XX-XX.

Логика:

Найти всех студентов в students/groups/<номер_группы>.

Для каждого студента в каждом файле теста Поп-Культуроведение/tests/TEST-[1-4] и Цирковое_Дело/tests/TEST-[1-4] посчитать число строк с его именем и нужной группой.

Для каждого теста считать пересдачами количество попыток минус одна (если попытка одна, пересдач 0).

Сложить пересдачи по всем тестам двух предметов.

Найти студента с минимальным значением и вывести Имя | Количество_пересдач.

Особенности:

При одинаковом минимуме можно вывести первого найденного.

При отсутствии данных по группе — вывести сообщение о том, что данных нет.

При некорректном вводе — сообщение с подсказкой вызова ./lab4.sh retakes -h.

Команда 2: badnames
Назначение:

Вывести список студентов группы, имена которых не соответствуют формату ФамилияИО (латиница, без пробелов).

Формат:

./lab4.sh badnames <номер_группы>

Входные данные:

Номер группы вида A-XX-XX или Ae-XX-XX.

Логика:

Считать всех студентов из students/groups/<номер_группы>.

Для каждого имени проверить соответствие регулярному выражению ^[A-Z][a-zA-Z]+[A-Z]{2}$.

Если имя не подходит — добавить его в список «плохих» имён.

Вывести заголовок и либо список таких студентов, либо сообщение, что все имена корректны.

Особенности:

При некорректном вводе — сообщение с подсказкой ./lab4.sh badnames -h.

Общие требования
Обработка ошибок ввода: отсутствие аргументов, лишние аргументы, неверный формат номера группы, неизвестные ключи.

Проверка существования файлов и директорий, прав на чтение.

Корректная обработка несуществующих групп.

Справка по каждой команде через --help или -h.

КОД ПРОГРАММЫ
Скрипт lab4.sh реализует обе требуемые команды (retake и check) с полной обработкой ошибок и валидацией входных данных. Он организован модульно: в начале идут функции справки и общие проверки, далее — реализация каждой команды с собственной логикой.

Структура скрипта
1. Функции справки
Скрипт содержит функции справки для каждой команды и для глобального режима:

print_global_help() — общая справка по всем доступным командам (retake, check) и форматам вызова.

print_retake_help() — подробная справка по команде retake, описание параметров (номер группы) и логики подсчёта пересдач.

print_check_help() — справка по команде check, объясняющая, что команда проверяет формат имён и наличие досье по всем группам.

Функции вызываются при передаче ключей -h или --help либо на глобальном уровне, либо после имени команды.

2. Валидация входных данных
Для каждой команды реализована многоуровневая проверка:

Проверка наличия и количества аргументов ($#), чтобы отлавливать отсутствие группы для retake и лишние параметры для check.

Проверка формата номера группы регулярным выражением ^(A|Ae)-[0-9]{2}-[0-9]{2}$ в команде retake.

Проверка существования файла группы students/groups/<номер_группы> и прав на чтение этого файла.

Проверка существования и доступности директорий students/groups и students/general/notes в команде check.

Проверка неизвестных ключей вида --something на уровне команды и на уровне её аргументов; при обнаружении выводится понятное сообщение с подсказкой по использованию -h.

При любом нарушении условий скрипт выводит информативное сообщение об ошибке и завершает работу с ненулевым кодом возврата.

3. Реализация команд
Команда retake
Фрагмент логики подсчёта пересдач (неудовлетворительных оценок) для студентов группы:

bash
declare -A RETAKE_COUNT
POP_PATH="Поп-Культуроведение/tests"
CIRCUS_PATH="Цирковое_Дело/tests"

# Инициализация счётчиков для всех студентов группы
while read -r student; do
    [[ -z "$student" ]] && continue
    RETAKE_COUNT["$student"]=0
done < "$GROUP_FILE"

count_retakes_in_file() {
    local test_file="$1"
    [[ ! -f "$test_file" ]] && return
    if [[ ! -r "$test_file" ]]; then
        echo "Ошибка: нет прав на чтение файла теста $test_file (Permission denied)"
        exit 1
    fi

    while IFS=';' read -r group student date score grade; do
        grade=$(echo "$grade" | tr -d ' ')
        if [[ "$group" == "$GROUP" ]] && [[ -n "${RETAKE_COUNT[$student]}" ]]; then
            if [[ "$grade" == "2" || "$grade" == "1" ]]; then
                RETAKE_COUNT["$student"]=$((RETAKE_COUNT["$student"] + 1))
            fi
        fi
    done < "$test_file"
}

for subject in "$POP_PATH" "$CIRCUS_PATH"; do
    for test_file in "$subject"/TEST-*; do
        count_retakes_in_file "$test_file"
    done
done

min_retakes=9999
best_student=""
for student in "${!RETAKE_COUNT[@]}"; do
    count=${RETAKE_COUNT[$student]}
    if [[ $count -lt $min_retakes ]]; then
        min_retakes=$count
        best_student=$student
    fi
done
Логика:

Читаем список студентов из файла students/groups/<группа> и инициализируем для каждого счётчик пересдач нулём.

Для каждого тестового файла двух предметов (Поп-Культуроведение/tests/TEST-* и Цирковое_Дело/tests/TEST-*) разбираем CSV‑строки через while IFS=';' read ....

Если строка относится к нужной группе и студенту, а оценка равна 1 или 2, увеличиваем счётчик пересдач этого студента.

После обхода всех тестов проходим по ассоциативному массиву RETAKE_COUNT и находим студента с минимальным количеством пересдач.

Выводим результат в формате:

text
retake:
<ИмяСтудента> | <количество_пересдач>
Команда check
Фрагмент логики проверки формата имён и досье:

bash
NOTES_DIR="students/general/notes"
GROUPS_DIR="students/groups"

declare -A DOSSIER_MAP
for file in "$NOTES_DIR"/*Names.log; do
    if [[ -f "$file" && -r "$file" ]]; then
        letter=$(basename "$file" | cut -c1)
        DOSSIER_MAP["$letter"]="$file"
    fi
done

found_issues=0

for group_file in "$GROUPS_DIR"/*; do
    [[ ! -f "$group_file" ]] && continue
    [[ ! -r "$group_file" ]] && echo "  (Пропущен файл ${group_file##*/}: нет прав)" && continue

    group_name=$(basename "$group_file")

    while read -r student; do
        [[ -z "$student" ]] && continue

        if [[ ! "$student" =~ ^[A-Z][a-z]+[A-Z][A-Z]$ ]]; then
            echo "  $group_name | $student | Неверный формат (должно быть 'ФамилияИО')"
            found_issues=1
            continue
        fi

        first_letter="${student:0:1}"
        if [[ -z "${DOSSIER_MAP[$first_letter]}" ]]; then
            echo "  $group_name | $student | Файл досье ${first_letter}Names.log не найден"
            found_issues=1
            continue
        fi

        dossier_file="${DOSSIER_MAP[$first_letter]}"
        if ! grep -q "^$student\$" "$dossier_file"; then
            echo "  $group_name | $student | Нет записи в файле досье ${dossier_file##*/}"
            found_issues=1
        fi
    done < "$group_file"
done

if [[ $found_issues -eq 0 ]]; then
    echo "  Все студенты соответствуют формату и имеют досье."
fi
Логика:

Проверяем доступность директорий students/general/notes и students/groups.

Строим карту буква → файл досье по файлам *Names.log.

Для каждого файла группы в students/groups читаем всех студентов.

Для каждого студента:

проверяем соответствие регулярному выражению формата ФамилияИО (^[A-Z][a-z]+[A-Z][A-Z]$);

по первой букве фамилии ищем соответствующий файл досье;

проверяем наличие строки с именем студента в файле досье.

При любом нарушении выводим строку вида:

text
<Группа> | <ИмяСтудента> | <описание проблемы>
Если нарушений не найдено, выводим сообщение, что все студенты соответствуют формату и имеют досье.

4. Обработка ошибок
Скрипт обрабатывает следующие типы ошибок.

Ошибки ввода:

Отсутствие аргументов (./lab4.sh без параметров).

Неверное количество аргументов для retake (нет группы или лишний аргумент).

Наличие аргументов у команды check, которая не требует параметров.

Неверный формат номера группы.

Передача неизвестных ключей (--unknown) как первой команды или в качестве аргумента команды.

Ошибки файловой системы:

Несуществующая группа (нет файла students/groups/<группа>).

Отсутствие прав на чтение файла группы.

Отсутствие прав на чтение тестовых файлов.

Отсутствие доступа к директориям students/groups или students/general/notes.

Отсутствие файла досье *Names.log для нужной буквы.

Специальные случаи:

Пустые строки в файлах групп (пропускаются).

Ситуация, когда по группе нет ни одного студента или данные о пересдачах отсутствуют — выводится аккуратное сообщение вместо «мусора».

Несколько студентов с одинаковым минимальным числом пересдач — выводится первый найденный, как оговорено с заказчиком.

5. Особенности реализации
Использование shopt -s nullglob позволяет избегать ошибок при отсутствии файлов, подходящих под шаблон TEST-*.

Ассоциативные массивы (declare -A) применяются для:

хранения счётчиков пересдач по студентам (RETAKE_COUNT);

построения карты соответствия первой буквы фамилии и файла досье (DOSSIER_MAP).

Для безопасного разбора CSV используется конструкция while IFS=';' read ..., что корректно обрабатывает пробелы в полях.

Валидация формата групп и имён строится на регулярных выражениях, что упрощает расширение форматов в будущем.

Вывод сообщений старается быть лаконичным: только нужная информация по команде, без лишних отладочных строк, что важно для автоматической проверки.
